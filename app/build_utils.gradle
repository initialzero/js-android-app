/*
 * Copyright Â© 2015 TIBCO Software, Inc. All rights reserved.
 * http://community.jaspersoft.com/project/jaspermobile-android
 *
 * Unless you have purchased a commercial license agreement from Jaspersoft,
 * the following license terms apply:
 *
 * This program is part of TIBCO Jaspersoft Mobile for Android.
 *
 * TIBCO Jaspersoft Mobile is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * TIBCO Jaspersoft Mobile is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with TIBCO Jaspersoft Mobile for Android. If not, see
 * <http://www.gnu.org/licenses/lgpl>.
 */

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'org.ajoberstar:gradle-git:1.1.0'
    }
}

import org.ajoberstar.grgit.*

import java.text.NumberFormat

ext {
    versionFile = new File(project.rootDir, 'version.properties')
    currentBranch = getCurrentBranch()
    baseAppName = "jaspermobile"
}

android {
    afterEvaluate {
        Properties currentAppVersion = getCurrentAppVersion()
        Properties savedAppVersion = getVersionFromFile()

        int revision = getRevisionNumber(currentAppVersion, savedAppVersion)
        int testBuildNumber = getTestBuildNumber(savedAppVersion)

        String versionNumber = generateVersionNumber(currentAppVersion, revision)
        int versionCode = generateVersionCodeValue(currentAppVersion, revision) as int

        //update values for different build tasks
        applicationVariants.all { variant ->
            String versionName = generateVersionName(versionNumber, testBuildNumber, variant.name as String)

            variant.mergedFlavor.versionCode = versionCode
            variant.mergedFlavor.versionName = versionName

            renameApk(variant, generateApkName(versionName), versionNumber)
        }
    }
}
//---------------------------------------------------------------------
// Helper methods
//---------------------------------------------------------------------
/**
 * Return current branch name
 * @return current branch
 */
String getCurrentBranch() {
    def repo = Grgit.open(project.rootDir)
    String branch = repo.branch.getCurrent().getName()
    return branch.replaceAll("/", "_")
}

/**
 * Check if current branch is "develop", "master", "release" or "hotfix".
 * @return if current branch is one of production branches
 */
boolean currentBranchIsProd() {
    return (currentBranch.equalsIgnoreCase("develop") ||
            currentBranch.equalsIgnoreCase("master") ||
            currentBranch.equalsIgnoreCase("hotfix")) ||
            currentBranch.equalsIgnoreCase("release");
}

/**
 * Check if current branch is "QA".
 * @return if current branch is branch for test
 */
boolean currentBranchIsQa() {
    return (currentBranch.equalsIgnoreCase("QA"));
}

/**
 * Return app version from gradle build defaultConfig.
 * @return app version as Bundle that contains 'major", "minor" and "patch" values.
 */
Properties getCurrentAppVersion() {
    Properties appVersion = new Properties()
    String appVersionName = android.defaultConfig.versionName as String

    if (appVersionName ==~ /(\d).(\d{1,2}).(\d{1,2})/) {
        def versions = appVersionName.tokenize('.')

        appVersion['major'] = versions[0]
        appVersion['minor'] = versions[1]
        appVersion['patch'] = versions[2]

        return appVersion as Properties
    } else throw new InvalidPropertiesFormatException("Version name does not match pattern available pattern!")
}

/**
 * Return revision number (build number) of current app version
 * @param currentAppVersion app version as Bundle
 * @return revision number for identifying various build number
 */
int getRevisionNumber(Properties currentAppVersion, Properties savedAppVersion) {
    int revision = 0 as int //0..999

    if (savedAppVersion != null)
        if (savedAppVersion['major'] as int == currentAppVersion['major']  &&
                savedAppVersion['minor'] as int == currentAppVersion['minor']  &&
                savedAppVersion['patch'] as int == currentAppVersion['patch'] )
            revision = savedAppVersion['revision'] as int

    return revision
}

/**
 * Return revision number (build number) of current app version
 * @param currentAppVersion app version as Bundle
 * @return revision number for identifying various build number
 */
int getTestBuildNumber(Properties savedAppVersion) {
    def testBuildNumber
    if (savedAppVersion != null)
        testBuildNumber = savedAppVersion['testBuildNumber']
    if (testBuildNumber != null) return testBuildNumber as int

    return 0
}

/**
 * Return app version bundle that was saved in file
 */
Properties getVersionFromFile() {
    Properties version = new Properties()
    def stream

    try {
        stream = new FileInputStream(versionFile)
        version.load(stream)
    } catch (FileNotFoundException ignore) {
        return null
    } finally {
        if (stream != null) stream.close()
    }

    // safety defaults in case file is missing
    if (!version['major'] || !version['minor'] || !version['patch'] || !version['revision']) return null

    return version
}

/**
 * Return text representation of app version.
 * Pattern for version number: "x.y.z.vvv"
 * where:
 * x - major version number
 * y - minor version number
 * z - patch version
 * vvv - revision number
 * @param appVersion app version bundle
 * @param revisionNumber current revision number
 * @return text representation of app version
 */
String generateVersionNumber(Properties appVersion, int revisionNumber) {
    def format = NumberFormat.getInstance()
    format.setMinimumIntegerDigits(1)

    String major = format.format(appVersion['major'] as int) // 1..?
    String minor = format.format(appVersion['minor'] as int) // 0..99
    String patch = format.format(appVersion['patch'] as int) // 0..99

    format.setMinimumIntegerDigits(3)
    String revision = format.format(revisionNumber)

    return "${major}.${minor}.${patch}.${revision}"
}

/**
 * Return version code of app version. Used for Google Play build identification.
 * Pattern for version code: "xxyyzzvvv"
 * where:
 * xx - major version number
 * yy - minor version number
 * zz - patch version
 * vvv - revision number
 */
int generateVersionCodeValue(Properties appVersion, int revisionNumber) {
    String versionCode = ""

    def format = NumberFormat.getInstance()
    format.setMinimumIntegerDigits(2)

    versionCode += format.format(appVersion.major as int)
    versionCode += format.format(appVersion.minor as int)
    versionCode += format.format(appVersion.patch as int)

    format.setMinimumIntegerDigits(3)
    versionCode += format.format(revisionNumber)

    return Integer.valueOf(versionCode)
}

/**
 * Returns version name considering current branch and current flavor
 * Version name pattern: "x.y.z.vvvv.ttttt-BRANCH_NAME-FLAVOR_TYPE"
 * where:
 * ttttt - current test build number - empty for builds that are not from QA branch
 * BRANCH_NAME - current branch name - empty for production branches
 * FLAVOR_TYPE - current flavor type - empty for production release builds
 * @param versionNumber version number for current build
 * @param testBuildNumber version number for QA build
 * @param flavorName name of flavor that is currently building
 * @return version name for build
 */
String generateVersionName(String versionNumber, int testBuildNumber, String flavorName) {
    String branchNamePart = currentBranchIsProd() ? "" : "-${currentBranch}"
    String testBuildPart = currentBranchIsQa() ? ".${testBuildNumber}" : ""

    String versionName = "${versionNumber}${branchNamePart}${testBuildPart}"

    if (flavorName.equalsIgnoreCase("devRelease")) {
        versionName = "${versionName}-SIGNED"
    } else if (flavorName.equalsIgnoreCase("devDebug")) {
        versionName = "${versionName}-SNAPSHOT"
    }
    return versionName;
}

/**
 * Returns new apk name based on version name
 * Apk name pattern: "jaspermobile-x.y.z.vvvv.ttttt-BRANCH_NAME-FLAVOR_TYPE"
 * @param versionName
 * @return
 */
String generateApkName(String versionName) {
    return "${baseAppName}-${versionName}"
}

void renameApk(flavor, String apkName, String versionNumber) {
    def outputs = flavor.outputs

    outputs.each { output ->
        if (flavor.buildType.zipAlignEnabled) {
            // normal APK
            output.outputFile = new File(output.outputFile.parent, "${apkName}.apk")
        }
        // 'unaligned' APK
        String unalignedApkName = "${baseAppName}-${versionNumber}-unaligned.apk"
        output.packageApplication.outputFile = new File(output.packageApplication.outputFile.parent, unalignedApkName)
    }
}